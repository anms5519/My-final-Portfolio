<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Blitz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #1f243a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            color: #e0e0e0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 800px;
            max-width: 100%;
            margin: 0 auto;
        }
        canvas {
            background-color: #131626;
            border: 2px solid #6b7b9c;
            box-shadow: 0 0 20px rgba(107, 123, 156, 0.5);
            display: block;
            margin: 0 auto;
        }
        h1 {
            margin-bottom: 20px;
            text-align: center;
            font-size: 2.5rem;
            color: #6b7b9c;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(90deg, #6b7b9c, #4ecca3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            width: 800px;
            max-width: 100%;
        }
        .controls p {
            margin: 5px 0;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            width: 800px;
            max-width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .status-label {
            font-size: 0.9rem;
            opacity: 0.7;
        }
        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4ecca3;
        }
        button {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: #4ecca3;
            color: #1f243a;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background-color: #3aa188;
            transform: scale(1.05);
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            border-radius: 10px;
        }
        #overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        #overlay h2 {
            font-size: 2.5rem;
            color: #4ecca3;
            margin-bottom: 20px;
            text-align: center;
        }
        #overlay p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }
        .lives-container {
            display: flex;
            gap: 5px;
        }
        .life {
            width: 20px;
            height: 20px;
            background-color: #ff5252;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .life.lost {
            background-color: rgba(255, 82, 82, 0.3);
        }
        .power-up {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            }
            to {
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }
        #level-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2rem;
            color: #4ecca3;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.5s ease;
            text-align: center;
            pointer-events: none;
        }
        #level-message.visible {
            opacity: 1;
        }
        @media (max-width: 850px) {
            #game-container, canvas, .status-bar, .controls {
                width: 95vw;
            }
            canvas {
                height: auto;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <h1>BREAKOUT BLITZ</h1>
    
    <div class="status-bar">
        <div class="status-item">
            <div class="status-label">Score</div>
            <div class="status-value" id="score">0</div>
        </div>
        <div class="status-item">
            <div class="status-label">Level</div>
            <div class="status-value" id="level">1</div>
        </div>
        <div class="status-item">
            <div class="status-label">Lives</div>
            <div class="lives-container" id="lives-container">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
        </div>
    </div>
    
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="level-message"></div>
        <div id="overlay">
            <h2 id="overlay-title">Game Over</h2>
            <p id="overlay-message">Your score: 0</p>
            <button id="restart-btn">Play Again</button>
        </div>
    </div>
    
    <div class="controls">
        <p>Use Left/Right Arrow keys or Mouse to move paddle</p>
        <p>Press Space to launch ball</p>
        <button id="start-btn">Start Game</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Canvas setup
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Game elements
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const livesContainer = document.getElementById('lives-container');
            const startBtn = document.getElementById('start-btn');
            const restartBtn = document.getElementById('restart-btn');
            const overlay = document.getElementById('overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const levelMessage = document.getElementById('level-message');
            
            // Game constants
            const PADDLE_WIDTH = 100;
            const PADDLE_HEIGHT = 20;
            const PADDLE_SPEED = 10;
            const BALL_RADIUS = 10;
            const INITIAL_BALL_SPEED = 5;
            const BRICK_ROWS = 5;
            const BRICK_COLS = 10;
            const BRICK_WIDTH = 75;
            const BRICK_HEIGHT = 20;
            const BRICK_PADDING = 10;
            const BRICK_TOP_OFFSET = 60;
            const BRICK_LEFT_OFFSET = 35;
            const POWER_UP_CHANCE = 0.2;
            const POWER_UP_SPEED = 2;
            
            // Power-up types
            const POWER_UPS = {
                EXPAND: { color: '#4ecca3', symbol: 'E', effect: 'Expand Paddle' },
                SLOW: { color: '#ffcc00', symbol: 'S', effect: 'Slow Ball' },
                MULTI: { color: '#ff5252', symbol: 'M', effect: 'Multi-Ball' },
                LIFE: { color: '#ff69b4', symbol: 'L', effect: 'Extra Life' },
                LASER: { color: '#6b7b9c', symbol: 'Z', effect: 'Laser Paddle' }
            };
            
            // Game state
            let gameState = {
                running: false,
                level: 1,
                score: 0,
                lives: 3,
                activePowerUps: [],
                powerUpTimer: null,
                bricks: [],
                paddle: {
                    x: canvas.width / 2 - PADDLE_WIDTH / 2,
                    y: canvas.height - PADDLE_HEIGHT - 10,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    dx: 0,
                    speed: PADDLE_SPEED,
                    expanded: false,
                    laser: false
                },
                balls: [],
                powerUps: [],
                lasers: []
            };
            
            // Initialize the game
            function init() {
                createBricks();
                resetBall();
                resetPaddle();
                updateLivesDisplay();
                scoreElement.textContent = gameState.score;
                levelElement.textContent = gameState.level;
                
                clearTimeout(gameState.powerUpTimer);
                gameState.activePowerUps = [];
                gameState.powerUps = [];
                gameState.lasers = [];
                gameState.running = false;
                
                overlay.classList.remove('visible');
                
                // Draw initial state
                draw();
            }
            
            // Create brick layout
            function createBricks() {
                gameState.bricks = [];
                
                for (let row = 0; row < BRICK_ROWS; row++) {
                    for (let col = 0; col < BRICK_COLS; col++) {
                        // Calculate brick position
                        const x = col * (BRICK_WIDTH + BRICK_PADDING) + BRICK_LEFT_OFFSET;
                        const y = row * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_TOP_OFFSET;
                        
                        // Determine brick properties based on level and row
                        let hits = 1;
                        let color = '#4ecca3';
                        
                        if (gameState.level > 1) {
                            if (row < 1) {
                                hits = Math.min(gameState.level, 3);
                                color = '#ff5252';
                            } else if (row < 2) {
                                hits = Math.min(gameState.level - 1, 2);
                                color = '#ffcc00';
                            }
                        }
                        
                        // Create brick object
                        gameState.bricks.push({
                            x,
                            y,
                            width: BRICK_WIDTH,
                            height: BRICK_HEIGHT,
                            visible: true,
                            hits,
                            maxHits: hits,
                            color,
                            hasPowerUp: Math.random() < POWER_UP_CHANCE
                        });
                    }
                }
            }
            
            // Reset ball to starting position
            function resetBall() {
                gameState.balls = [{
                    x: canvas.width / 2,
                    y: canvas.height - PADDLE_HEIGHT - BALL_RADIUS - 20,
                    dx: 0,
                    dy: 0,
                    radius: BALL_RADIUS,
                    speed: INITIAL_BALL_SPEED,
                    active: true,
                    launched: false
                }];
            }
            
            // Reset paddle to starting position
            function resetPaddle() {
                gameState.paddle.x = canvas.width / 2 - gameState.paddle.width / 2;
                gameState.paddle.y = canvas.height - PADDLE_HEIGHT - 10;
                gameState.paddle.expanded = false;
                gameState.paddle.laser = false;
                gameState.paddle.width = PADDLE_WIDTH;
            }
            
            // Update lives display
            function updateLivesDisplay() {
                const lifeElements = livesContainer.querySelectorAll('.life');
                
                for (let i = 0; i < lifeElements.length; i++) {
                    if (i < gameState.lives) {
                        lifeElements[i].classList.remove('lost');
                    } else {
                        lifeElements[i].classList.add('lost');
                    }
                }
            }
            
            // Launch the ball
            function launchBall() {
                if (!gameState.running) return;
                
                gameState.balls.forEach(ball => {
                    if (!ball.launched) {
                        // Random angle between -45 and 45 degrees (in radians)
                        const angle = (Math.random() * 90 - 45) * Math.PI / 180;
                        
                        ball.dx = ball.speed * Math.sin(angle);
                        ball.dy = -ball.speed * Math.cos(angle);
                        ball.launched = true;
                    }
                });
            }
            
            // Draw game elements
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw bricks
                drawBricks();
                
                // Draw paddle
                drawPaddle();
                
                // Draw balls
                drawBalls();
                
                // Draw power-ups
                drawPowerUps();
                
                // Draw lasers
                drawLasers();
                
                // Draw active power-up effects
                drawPowerUpEffects();
            }
            
            // Draw bricks
            function drawBricks() {
                gameState.bricks.forEach(brick => {
                    if (brick.visible) {
                        ctx.fillStyle = brick.color;
                        
                        // Adjust color based on hits remaining
                        if (brick.maxHits > 1) {
                            const opacity = 0.4 + (0.6 * brick.hits / brick.maxHits);
                            ctx.fillStyle = brick.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                        }
                        
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        
                        // Add highlight for multi-hit bricks
                        if (brick.hits > 1) {
                            ctx.font = '12px Arial';
                            ctx.fillStyle = '#ffffff';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(brick.hits, brick.x + brick.width / 2, brick.y + brick.height / 2);
                        }
                        
                        // Add border
                        ctx.strokeStyle = '#131626';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });
            }
            
            // Draw paddle
            function drawPaddle() {
                // Create gradient for paddle
                const gradient = ctx.createLinearGradient(
                    gameState.paddle.x, 
                    gameState.paddle.y, 
                    gameState.paddle.x + gameState.paddle.width, 
                    gameState.paddle.y + gameState.paddle.height
                );
                
                if (gameState.paddle.laser) {
                    gradient.addColorStop(0, '#6b7b9c');
                    gradient.addColorStop(1, '#4ecca3');
                    
                    // Draw laser charging indicators
                    ctx.fillStyle = '#6b7b9c';
                    ctx.fillRect(gameState.paddle.x + 10, gameState.paddle.y - 5, 8, 5);
                    ctx.fillRect(gameState.paddle.x + gameState.paddle.width - 18, gameState.paddle.y - 5, 8, 5);
                } else {
                    gradient.addColorStop(0, '#4ecca3');
                    gradient.addColorStop(1, '#3aa188');
                }
                
                // Draw paddle body
                ctx.fillStyle = gradient;
                ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height);
                
                // Add highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, 5);
            }
            
            // Draw balls
            function drawBalls() {
                gameState.balls.forEach(ball => {
                    if (ball.active) {
                        ctx.beginPath();
                        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                        ctx.closePath();
                        
                        // Add highlight
                        ctx.beginPath();
                        ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fill();
                        ctx.closePath();
                    }
                });
            }
            
            // Draw power-ups
            function drawPowerUps() {
                gameState.powerUps.forEach(powerUp => {
                    ctx.fillStyle = powerUp.color;
                    ctx.beginPath();
                    ctx.arc(powerUp.x, powerUp.y, powerUp.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    
                    // Draw power-up symbol
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(powerUp.symbol, powerUp.x, powerUp.y);
                });
            }
            
            // Draw lasers
            function drawLasers() {
                ctx.fillStyle = '#6b7b9c';
                
                gameState.lasers.forEach(laser => {
                    ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                    
                    // Add glow effect
                    ctx.shadowColor = '#6b7b9c';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                    ctx.shadowBlur = 0;
                });
            }
            
            // Draw power-up effects indicators
            function drawPowerUpEffects() {
                if (gameState.activePowerUps.length > 0) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    
                    let y = 10;
                    
                    gameState.activePowerUps.forEach(powerUp => {
                        ctx.fillStyle = powerUp.color;
                        ctx.fillText(`${powerUp.effect}`, 10, y);
                        y += 20;
                    });
                }
            }
            
            // Update game state
            function update() {
                if (!gameState.running) return;
                
                // Move paddle
                gameState.paddle.x += gameState.paddle.dx;
                
                // Keep paddle within canvas boundaries
                if (gameState.paddle.x < 0) {
                    gameState.paddle.x = 0;
                } else if (gameState.paddle.x + gameState.paddle.width > canvas.width) {
                    gameState.paddle.x = canvas.width - gameState.paddle.width;
                }
                
                // Update ball position
                updateBalls();
                
                // Update power-ups
                updatePowerUps();
                
                // Update lasers
                updateLasers();
                
                // Draw updated state
                draw();
                
                // Check if all bricks are destroyed
                checkLevelCompletion();
                
                // Request next frame
                requestAnimationFrame(update);
            }
            
            // Update all balls
            function updateBalls() {
                // Update ball positions and check for collisions
                gameState.balls.forEach((ball, index) => {
                    if (!ball.active) return;
                    
                    // If ball isn't launched, keep it on the paddle
                    if (!ball.launched) {
                        ball.x = gameState.paddle.x + gameState.paddle.width / 2;
                        return;
                    }
                    
                    // Move ball
                    ball.x += ball.dx;
                    ball.y += ball.dy;
                    
                    // Wall collision
                    if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
                        ball.dx = -ball.dx;
                        // Keep ball within canvas
                        if (ball.x - ball.radius < 0) {
                            ball.x = ball.radius;
                        } else if (ball.x + ball.radius > canvas.width) {
                            ball.x = canvas.width - ball.radius;
                        }
                    }
                    
                    // Top wall collision
                    if (ball.y - ball.radius < 0) {
                        ball.dy = -ball.dy;
                        ball.y = ball.radius; // Keep ball within canvas
                    }
                    
                    // Bottom wall collision (ball lost)
                    if (ball.y + ball.radius > canvas.height) {
                        ball.active = false;
                        
                        // Check if it's the last active ball
                        const activeBalls = gameState.balls.filter(b => b.active);
                        if (activeBalls.length === 0) {
                            gameState.lives--;
                            updateLivesDisplay();
                            
                            if (gameState.lives <= 0) {
                                gameOver();
                            } else {
                                resetBall();
                                resetPaddle();
                            }
                        }
                    }
                    
                    // Paddle collision
                    if (
                        ball.y + ball.radius > gameState.paddle.y &&
                        ball.y - ball.radius < gameState.paddle.y + gameState.paddle.height &&
                        ball.x > gameState.paddle.x &&
                        ball.x < gameState.paddle.x + gameState.paddle.width
                    ) {
                        // Calculate ball position relative to paddle center (from -1 to 1)
                        const hitPosition = (ball.x - (gameState.paddle.x + gameState.paddle.width / 2)) / (gameState.paddle.width / 2);
                        
                        // Calculate new angle (more angle at edges, flatter in center)
                        const angle = hitPosition * Math.PI / 3; // 60 degrees max
                        
                        // Set new velocity
                        ball.dx = ball.speed * Math.sin(angle);
                        ball.dy = -ball.speed * Math.cos(angle);
                        
                        // Ensure ball doesn't get stuck in paddle
                        ball.y = gameState.paddle.y - ball.radius;
                    }
                    
                    // Brick collision
                    checkBrickCollisions(ball);
                });
                
                // Filter out inactive balls
                gameState.balls = gameState.balls.filter(ball => ball.active);
            }
            
            // Check ball collisions with bricks
            function checkBrickCollisions(ball) {
                gameState.bricks.forEach(brick => {
                    if (brick.visible && 
                        ball.x + ball.radius > brick.x && 
                        ball.x - ball.radius < brick.x + brick.width &&
                        ball.y + ball.radius > brick.y && 
                        ball.y - ball.radius < brick.y + brick.height) {
                        
                        // Determine which side of the brick the ball hit
                        const hitX = ball.x < brick.x ? brick.x : (ball.x > brick.x + brick.width ? brick.x + brick.width : ball.x);
                        const hitY = ball.y < brick.y ? brick.y : (ball.y > brick.y + brick.height ? brick.y + brick.height : ball.y);
                        
                        const distX = ball.x - hitX;
                        const distY = ball.y - hitY;
                        
                        // Horizontal or vertical collision?
                        if (Math.abs(distX) > Math.abs(distY)) {
                            ball.dx = -ball.dx;
                        } else {
                            ball.dy = -ball.dy;
                        }
                        
                        // Reduce brick hits
                        brick.hits--;
                        
                        // Award points
                        gameState.score += 10 * brick.maxHits;
                        scoreElement.textContent = gameState.score;
                        
                        // Check if brick is destroyed
                        if (brick.hits <= 0) {
                            brick.visible = false;
                            
                            // Release power-up if brick has one
                            if (brick.hasPowerUp) {
                                releasePowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                            }
                        }
                    }
                });
            }
            
            // Update power-ups
            function updatePowerUps() {
                gameState.powerUps.forEach((powerUp, index) => {
                    // Move power-up down
                    powerUp.y += POWER_UP_SPEED;
                    
                    // Check if power-up is caught by paddle
                    if (
                        powerUp.y + powerUp.size > gameState.paddle.y &&
                        powerUp.y - powerUp.size < gameState.paddle.y + gameState.paddle.height &&
                        powerUp.x + powerUp.size > gameState.paddle.x &&
                        powerUp.x - powerUp.size < gameState.paddle.x + gameState.paddle.width
                    ) {
                        // Apply power-up effect
                        applyPowerUp(powerUp);
                        
                        // Remove power-up
                        gameState.powerUps.splice(index, 1);
                    }
                    
                    // Remove power-up if it goes off-screen
                    if (powerUp.y - powerUp.size > canvas.height) {
                        gameState.powerUps.splice(index, 1);
                    }
                });
            }
            
            // Update lasers
            function updateLasers() {
                gameState.lasers.forEach((laser, laserIndex) => {
                    // Move laser up
                    laser.y -= laser.speed;
                    
                    // Check for brick collisions
                    gameState.bricks.forEach(brick => {
                        if (brick.visible && 
                            laser.x < brick.x + brick.width && 
                            laser.x + laser.width > brick.x && 
                            laser.y < brick.y + brick.height && 
                            laser.y + laser.height > brick.y) {
                            
                            // Reduce brick hits
                            brick.hits--;
                            
                            // Award points
                            gameState.score += 5 * brick.maxHits;
                            scoreElement.textContent = gameState.score;
                            
                            // Check if brick is destroyed
                            if (brick.hits <= 0) {
                                brick.visible = false;
                                
                                // Release power-up if brick has one
                                if (brick.hasPowerUp) {
                                    releasePowerUp(brick.x + brick.width / 2, brick.y + brick.height / 2);
                                }
                            }
                            
                            // Remove laser
                            gameState.lasers.splice(laserIndex, 1);
                        }
                    });
                    
                    // Remove laser if it goes off-screen
                    if (laser.y + laser.height < 0) {
                        gameState.lasers.splice(laserIndex, 1);
                    }
                });
            }
            
            // Release power-up from brick
            function releasePowerUp(x, y) {
                // Select random power-up
                const powerUpKeys = Object.keys(POWER_UPS);
                const powerUpType = powerUpKeys[Math.floor(Math.random() * powerUpKeys.length)];
                const powerUp = POWER_UPS[powerUpType];
                
                // Create power-up object
                gameState.powerUps.push({
                    x,
                    y,
                    size: 15,
                    color: powerUp.color,
                    symbol: powerUp.symbol,
                    type: powerUpType,
                    effect: powerUp.effect
                });
            }
            
            // Apply power-up effect
            function applyPowerUp(powerUp) {
                switch (powerUp.type) {
                    case 'EXPAND':
                        // Expand paddle
                        gameState.paddle.width = PADDLE_WIDTH * 1.5;
                        gameState.paddle.expanded = true;
                        break;
                    case 'SLOW':
                        // Slow balls
                        gameState.balls.forEach(ball => {
                            ball.speed = INITIAL_BALL_SPEED * 0.7;
                            // Adjust current velocity
                            const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                            if (magnitude > 0) {
                                ball.dx = (ball.dx / magnitude) * ball.speed;
                                ball.dy = (ball.dy / magnitude) * ball.speed;
                            }
                        });
                        break;
                    case 'MULTI':
                        // Add extra balls
                        const activeBall = gameState.balls.find(ball => ball.active);
                        if (activeBall) {
                            // Create two new balls
                            for (let i = 0; i < 2; i++) {
                                const angle = (Math.random() * 120 - 60) * Math.PI / 180;
                                const newBall = {
                                    x: activeBall.x,
                                    y: activeBall.y,
                                    radius: BALL_RADIUS,
                                    dx: activeBall.speed * Math.sin(angle),
                                    dy: -activeBall.speed * Math.cos(angle),
                                    speed: activeBall.speed,
                                    active: true,
                                    launched: true
                                };
                                gameState.balls.push(newBall);
                            }
                        }
                        break;
                    case 'LIFE':
                        // Extra life
                        if (gameState.lives < 3) {
                            gameState.lives++;
                            updateLivesDisplay();
                        }
                        break;
                    case 'LASER':
                        // Enable laser paddle
                        gameState.paddle.laser = true;
                        break;
                }
                
                // Add to active power-ups
                gameState.activePowerUps.push({
                    type: powerUp.type,
                    color: powerUp.color,
                    effect: powerUp.effect
                });
                
                // Power-ups last for 15 seconds
                clearTimeout(gameState.powerUpTimer);
                gameState.powerUpTimer = setTimeout(() => {
                    resetPowerUps();
                }, 15000);
                
                // Show effect message
                showLevelMessage(powerUp.effect, 1500);
            }
            
            // Reset power-up effects
            function resetPowerUps() {
                gameState.paddle.width = PADDLE_WIDTH;
                gameState.paddle.expanded = false;
                gameState.paddle.laser = false;
                
                // Reset ball speeds
                gameState.balls.forEach(ball => {
                    ball.speed = INITIAL_BALL_SPEED;
                    // Adjust current velocity
                    const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    if (magnitude > 0) {
                        ball.dx = (ball.dx / magnitude) * ball.speed;
                        ball.dy = (ball.dy / magnitude) * ball.speed;
                    }
                });
                
                // Clear active power-ups
                gameState.activePowerUps = [];
            }
            
            // Fire lasers from paddle
            function fireLasers() {
                if (!gameState.paddle.laser) return;
                
                // Create two lasers (one from each side of the paddle)
                const laser1 = {
                    x: gameState.paddle.x + 15,
                    y: gameState.paddle.y - 20,
                    width: 4,
                    height: 20,
                    speed: 10
                };
                
                const laser2 = {
                    x: gameState.paddle.x + gameState.paddle.width - 19,
                    y: gameState.paddle.y - 20,
                    width: 4,
                    height: 20,
                    speed: 10
                };
                
                gameState.lasers.push(laser1, laser2);
            }
            
            // Check if level is complete
            function checkLevelCompletion() {
                const remainingBricks = gameState.bricks.filter(brick => brick.visible).length;
                
                if (remainingBricks === 0) {
                    levelComplete();
                }
            }
            
            // Level complete
            function levelComplete() {
                gameState.running = false;
                
                // Show level complete message
                overlayTitle.textContent = 'Level Complete!';
                overlayMessage.textContent = `Score: ${gameState.score}`;
                overlay.classList.add('visible');
                
                // Prepare for next level
                gameState.level++;
                levelElement.textContent = gameState.level;
                
                // Reset power-ups
                resetPowerUps();
            }
            
            // Game over
            function gameOver() {
                gameState.running = false;
                
                // Show game over message
                overlayTitle.textContent = 'Game Over';
                overlayMessage.textContent = `Final Score: ${gameState.score}`;
                overlay.classList.add('visible');
            }
            
            // Show temporary level message
            function showLevelMessage(text, duration) {
                levelMessage.textContent = text;
                levelMessage.classList.add('visible');
                
                setTimeout(() => {
                    levelMessage.classList.remove('visible');
                }, duration);
            }
            
            // Event listeners
            startBtn.addEventListener('click', () => {
                if (!gameState.running) {
                    init();
                    gameState.running = true;
                    startBtn.textContent = 'Pause Game';
                    update();
                } else {
                    gameState.running = false;
                    startBtn.textContent = 'Resume Game';
                }
            });
            
            restartBtn.addEventListener('click', () => {
                overlay.classList.remove('visible');
                if (gameState.lives <= 0) {
                    // Reset game
                    gameState.score = 0;
                    gameState.level = 1;
                    gameState.lives = 3;
                    scoreElement.textContent = gameState.score;
                    levelElement.textContent = gameState.level;
                }
                init();
                gameState.running = true;
                startBtn.textContent = 'Pause Game';
                update();
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    gameState.paddle.dx = -gameState.paddle.speed;
                } else if (e.key === 'ArrowRight') {
                    gameState.paddle.dx = gameState.paddle.speed;
                } else if (e.key === ' ') {
                    launchBall();
                } else if (e.key === 'Control') {
                    fireLasers();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' && gameState.paddle.dx < 0) {
                    gameState.paddle.dx = 0;
                } else if (e.key === 'ArrowRight' && gameState.paddle.dx > 0) {
                    gameState.paddle.dx = 0;
                }
            });
            
            // Mouse controls
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                // Set paddle position
                gameState.paddle.x = mouseX - gameState.paddle.width / 2;
                
                // Keep paddle within canvas boundaries
                if (gameState.paddle.x < 0) {
                    gameState.paddle.x = 0;
                } else if (gameState.paddle.x + gameState.paddle.width > canvas.width) {
                    gameState.paddle.x = canvas.width - gameState.paddle.width;
                }
            });
            
            canvas.addEventListener('click', () => {
                launchBall();
            });
            
            // Initialize the game
            init();
        });
    </script>
</body>
</html>